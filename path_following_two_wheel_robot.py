# -*- coding: utf-8 -*-
"""path following two wheel robot.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fpbGKsHyPS5EuVr374YlS9inLbJcoxCK
"""

import numpy as np
import matplotlib.pyplot as plt

# Robot parameters
R = 0.05  # Radius of the wheels
L = 0.2  # Distance between two wheels

# Generate path (sin)
path_x = np.linspace(0, 3*np.pi, 100)   #100 points between 0 and 3*pi
path_y = np.sin(path_x)

# Initial robot position and orientation
x = path_x[0]
y = path_y[0]
theta = 0
w_r = 0
w_l = 0
w = 0

# Simulation parameters
dt = 0.1  # Time step
t_end = len(path_x)*dt  # End time

# Arrays to store robot states
robot_x = np.array([x])
robot_y = np.array([y])
robot_theta = np.array([theta])
robot_wR = np.array([w_r])
robot_wL = np.array([w_l])
robot_w = np.array([w])

# Simulate path following
for t in np.arange(0, t_end-dt, dt):
    # Compute the desired linear and angular velocities to follow the path
    path_index = int(t/dt)  
    dx = path_x[path_index+1] - path_x[path_index]   # Distance between current and next point on path   
    dy = path_y[path_index+1] - path_y[path_index]
    desired_theta = np.arctan2(dy, dx)    # The “y-coordinate” is the first function parameter, the “x-coordinate” is the second
    desired_v = (np.sqrt(dx**2 + dy**2))/dt     # v = S/t
    desired_w = (desired_theta - theta)/dt
    
    # Compute the left and right wheel velocities based on the desired linear and angular velocities
    w_l = (desired_v - L/2*desired_w)/R
    w_r = (desired_v + L/2*desired_w)/R
    
    # Compute the robot's new position and orientation based on the wheel velocities
    V = R/2*(w_l + w_r)
    w = R/L*(w_r - w_l)
    x += V*np.cos(theta)*dt
    y += V*np.sin(theta)*dt
    theta += w*dt
    
    # Store the robot new states
    robot_x = np.append(robot_x, x)
    robot_y = np.append(robot_y, y)
    robot_theta = np.append(robot_theta, theta)
    robot_w = np.append(robot_w, w)
    robot_wR = np.append(robot_wR, w_r)
    robot_wL = np.append(robot_wL, w_l)

# Plot the result
plt.plot(path_x, path_y, '.', label='Original Path')
plt.plot(robot_x, robot_y, '.', label='Robot Path')
plt.legend()
plt.axis('equal')
plt.show()

# Print the values of w_l, w_r, w, theta, robot_x, and robot_y 
print("i\tw_l\tw_r\tw\ttheta\trobot_x\trobot_y")
for i in range(len(robot_wL)):
    print(f"{i}\t{robot_wL[i]:.4f}\t{robot_wR[i]:.4f}\t{robot_w[i]:.4f}\t{robot_theta[i]:.4f}\t{robot_x[i]:.4f}\t{robot_y[i]:.4f}")

